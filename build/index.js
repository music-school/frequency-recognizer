/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["frequencyRecognizer"] = factory();
	else
		root["frequencyRecognizer"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;\n\n//# sourceURL=webpack://frequencyRecognizer/./node_modules/@babel/runtime/helpers/asyncToGenerator.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;\n\n//# sourceURL=webpack://frequencyRecognizer/./node_modules/@babel/runtime/helpers/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n//# sourceURL=webpack://frequencyRecognizer/./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\n\n//# sourceURL=webpack://frequencyRecognizer/./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\n\n//# sourceURL=webpack://frequencyRecognizer/./node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "./external/aubio.js":
/*!***************************!*\
  !*** ./external/aubio.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar Aubio = function Aubio(_Aubio) {\n  _Aubio = _Aubio || {};\n  var c;\n  c || (c = typeof _Aubio !== 'undefined' ? _Aubio : {});\n  var n = {},\n      r;\n\n  for (r in c) {\n    c.hasOwnProperty(r) && (n[r] = c[r]);\n  }\n\n  c.arguments = [];\n  c.thisProgram = \"./this.program\";\n\n  c.quit = function (a, b) {\n    throw b;\n  };\n\n  c.preRun = [];\n  c.postRun = [];\n  var u = !1,\n      v = !1,\n      aa = !1,\n      ba = !1;\n  u = \"object\" === (typeof window === \"undefined\" ? \"undefined\" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(window));\n  v = \"function\" === typeof importScripts;\n  aa = \"object\" === (typeof process === \"undefined\" ? \"undefined\" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(process)) && \"function\" === \"function\" && !u && !v;\n  ba = !u && !aa && !v;\n  var w = \"\";\n\n  function ca(a) {\n    return c.locateFile ? c.locateFile(a, w) : w + a;\n  }\n\n  if (aa) {\n    w = __dirname + \"/\";\n    var da, ea;\n\n    c.read = function (a, b) {\n      da || (da = __webpack_require__(/*! fs */ \"fs\"));\n      ea || (ea = __webpack_require__(/*! path */ \"path\"));\n      a = ea.normalize(a);\n      a = da.readFileSync(a);\n      return b ? a : a.toString();\n    };\n\n    c.readBinary = function (a) {\n      a = c.read(a, !0);\n      a.buffer || (a = new Uint8Array(a));\n      assert(a.buffer);\n      return a;\n    };\n\n    1 < process.argv.length && (c.thisProgram = process.argv[1].replace(/\\\\/g, \"/\"));\n    c.arguments = process.argv.slice(2);\n    process.on(\"uncaughtException\", function (a) {\n      throw a;\n    });\n    process.on(\"unhandledRejection\", function () {\n      process.exit(1);\n    });\n\n    c.quit = function (a) {\n      process.exit(a);\n    };\n\n    c.inspect = function () {\n      return \"[Emscripten Module object]\";\n    };\n  } else if (ba) \"undefined\" != typeof read && (c.read = function (a) {\n    return read(a);\n  }), c.readBinary = function (a) {\n    if (\"function\" === typeof readbuffer) return new Uint8Array(readbuffer(a));\n    a = read(a, \"binary\");\n    assert(\"object\" === _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(a));\n    return a;\n  }, \"undefined\" != typeof scriptArgs ? c.arguments = scriptArgs : \"undefined\" != typeof arguments && (c.arguments = arguments), \"function\" === typeof quit && (c.quit = function (a) {\n    quit(a);\n  });else if (u || v) {\n    if (u) {\n      var fa = this._currentScript || document.currentScript;\n      0 !== fa.src.indexOf(\"blob:\") && (w = fa.src.split(\"/\").slice(0, -1).join(\"/\") + \"/\");\n    } else v && (w = self.location.href.split(\"/\").slice(0, -1).join(\"/\") + \"/\");\n\n    c.read = function (a) {\n      var b = new XMLHttpRequest();\n      b.open(\"GET\", a, !1);\n      b.send(null);\n      return b.responseText;\n    };\n\n    v && (c.readBinary = function (a) {\n      var b = new XMLHttpRequest();\n      b.open(\"GET\", a, !1);\n      b.responseType = \"arraybuffer\";\n      b.send(null);\n      return new Uint8Array(b.response);\n    });\n\n    c.readAsync = function (a, b, d) {\n      var e = new XMLHttpRequest();\n      e.open(\"GET\", a, !0);\n      e.responseType = \"arraybuffer\";\n\n      e.onload = function () {\n        200 == e.status || 0 == e.status && e.response ? b(e.response) : d();\n      };\n\n      e.onerror = d;\n      e.send(null);\n    };\n\n    c.setWindowTitle = function (a) {\n      document.title = a;\n    };\n  }\n\n  var ha = c.print || (\"undefined\" !== typeof console ? console.log.bind(console) : \"undefined\" !== typeof print ? print : null),\n      x = c.printErr || (\"undefined\" !== typeof printErr ? printErr : \"undefined\" !== typeof console && console.warn.bind(console) || ha);\n\n  for (r in n) {\n    n.hasOwnProperty(r) && (c[r] = n[r]);\n  }\n\n  n = void 0;\n\n  function ia(a) {\n    var b;\n    b || (b = 16);\n    return Math.ceil(a / b) * b;\n  }\n\n  var ja = {\n    \"f64-rem\": function f64Rem(a, b) {\n      return a % b;\n    },\n    \"debugger\": function _debugger() {\n      debugger;\n    }\n  },\n      ka = 0;\n\n  function assert(a, b) {\n    a || y(\"Assertion failed: \" + b);\n  }\n\n  var la = \"undefined\" !== typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n  \"undefined\" !== typeof TextDecoder && new TextDecoder(\"utf-16le\");\n  var buffer, ma, z, na, oa, A, B, pa, qa;\n\n  function ra() {\n    c.HEAP8 = ma = new Int8Array(buffer);\n    c.HEAP16 = na = new Int16Array(buffer);\n    c.HEAP32 = A = new Int32Array(buffer);\n    c.HEAPU8 = z = new Uint8Array(buffer);\n    c.HEAPU16 = oa = new Uint16Array(buffer);\n    c.HEAPU32 = B = new Uint32Array(buffer);\n    c.HEAPF32 = pa = new Float32Array(buffer);\n    c.HEAPF64 = qa = new Float64Array(buffer);\n  }\n\n  var sa, C, ta, ua, va, wa, xa;\n  sa = C = ta = ua = va = wa = xa = 0;\n\n  function ya() {\n    y(\"Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \" + E + \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \");\n  }\n\n  var za = c.TOTAL_STACK || 5242880,\n      E = c.TOTAL_MEMORY || 16777216;\n  E < za && x(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" + E + \"! (TOTAL_STACK=\" + za + \")\");\n  c.buffer ? buffer = c.buffer : (\"object\" === (typeof WebAssembly === \"undefined\" ? \"undefined\" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(WebAssembly)) && \"function\" === typeof WebAssembly.Memory ? (c.wasmMemory = new WebAssembly.Memory({\n    initial: E / 65536,\n    maximum: E / 65536\n  }), buffer = c.wasmMemory.buffer) : buffer = new ArrayBuffer(E), c.buffer = buffer);\n  ra();\n\n  function Aa(a) {\n    for (; 0 < a.length;) {\n      var b = a.shift();\n      if (\"function\" == typeof b) b();else {\n        var d = b.B;\n        \"number\" === typeof d ? void 0 === b.F ? c.dynCall_v(d) : c.dynCall_vi(d, b.F) : d(void 0 === b.F ? null : b.F);\n      }\n    }\n  }\n\n  var Ba = [],\n      Ca = [],\n      Da = [],\n      Ea = [],\n      Fa = !1;\n\n  function Ga() {\n    var a = c.preRun.shift();\n    Ba.unshift(a);\n  }\n\n  var Ha = Math.cos,\n      Ia = Math.sin,\n      F = 0,\n      Ja = null,\n      G = null;\n  c.preloadedImages = {};\n  c.preloadedAudios = {};\n\n  function Ka(a) {\n    return String.prototype.startsWith ? a.startsWith(\"data:application/octet-stream;base64,\") : 0 === a.indexOf(\"data:application/octet-stream;base64,\");\n  }\n\n  (function () {\n    function a() {\n      try {\n        if (c.wasmBinary) return new Uint8Array(c.wasmBinary);\n        if (c.readBinary) return c.readBinary(f);\n        throw \"both async and sync fetching of the wasm failed\";\n      } catch (g) {\n        y(g);\n      }\n    }\n\n    function b() {\n      return c.wasmBinary || !u && !v || \"function\" !== typeof fetch ? new Promise(function (b) {\n        b(a());\n      }) : fetch(f, {\n        credentials: \"same-origin\"\n      }).then(function (a) {\n        if (!a.ok) throw \"failed to load wasm binary file at '\" + f + \"'\";\n        return a.arrayBuffer();\n      })[\"catch\"](function () {\n        return a();\n      });\n    }\n\n    function d(a) {\n      function d(a) {\n        k = a.exports;\n\n        if (k.memory) {\n          a = k.memory;\n          var b = c.buffer;\n          a.byteLength < b.byteLength && x(\"the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here\");\n          b = new Int8Array(b);\n          new Int8Array(a).set(b);\n          c.buffer = buffer = a;\n          ra();\n        }\n\n        c.asm = k;\n        c.usingWasm = !0;\n        F--;\n        c.monitorRunDependencies && c.monitorRunDependencies(F);\n        0 == F && (null !== Ja && (clearInterval(Ja), Ja = null), G && (a = G, G = null, a()));\n      }\n\n      function e(a) {\n        d(a.instance);\n      }\n\n      function g(a) {\n        b().then(function (a) {\n          return WebAssembly.instantiate(a, h);\n        }).then(a)[\"catch\"](function (a) {\n          x(\"failed to asynchronously prepare wasm: \" + a);\n          y(a);\n        });\n      }\n\n      if (\"object\" !== (typeof WebAssembly === \"undefined\" ? \"undefined\" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(WebAssembly))) return x(\"no native wasm support detected\"), !1;\n      if (!(c.wasmMemory instanceof WebAssembly.Memory)) return x(\"no native wasm Memory in use\"), !1;\n      a.memory = c.wasmMemory;\n      h.global = {\n        NaN: NaN,\n        Infinity: Infinity\n      };\n      h[\"global.Math\"] = Math;\n      h.env = a;\n      F++;\n      c.monitorRunDependencies && c.monitorRunDependencies(F);\n      if (c.instantiateWasm) try {\n        return c.instantiateWasm(h, d);\n      } catch (vb) {\n        return x(\"Module.instantiateWasm callback failed with error: \" + vb), !1;\n      }\n      c.wasmBinary || \"function\" !== typeof WebAssembly.instantiateStreaming || Ka(f) || \"function\" !== typeof fetch ? g(e) : fetch(f, {\n        credentials: \"same-origin\"\n      }).then(function (response) {\n        return response.arrayBuffer();\n      }).then(function (bytes) {\n        return WebAssembly.instantiate(bytes, h);\n      }).then(e)[\"catch\"](function (a) {\n        x(\"wasm streaming compile failed: \" + a);\n        x(\"falling back to ArrayBuffer instantiation\");\n        g(e);\n      });\n      return {};\n    }\n\n    var e = \"aubio.wast\",\n        f = \"aubio.wasm\",\n        l = \"aubio.temp.asm.js\";\n    Ka(e) || (e = ca(e));\n    Ka(f) || (f = ca(f));\n    Ka(l) || (l = ca(l));\n    var h = {\n      global: null,\n      env: null,\n      asm2wasm: ja,\n      parent: c\n    },\n        k = null;\n    c.asmPreload = c.asm;\n    var m = c.reallocBuffer;\n\n    c.reallocBuffer = function (a) {\n      if (\"asmjs\" === p) var b = m(a);else a: {\n        var d = c.usingWasm ? 65536 : 16777216;\n        0 < a % d && (a += d - a % d);\n        d = c.buffer.byteLength;\n        if (c.usingWasm) try {\n          b = -1 !== c.wasmMemory.grow((a - d) / 65536) ? c.buffer = c.wasmMemory.buffer : null;\n          break a;\n        } catch (t) {\n          b = null;\n          break a;\n        }\n        b = void 0;\n      }\n      return b;\n    };\n\n    var p = \"\";\n\n    c.asm = function (a, b) {\n      if (!b.table) {\n        a = c.wasmTableSize;\n        void 0 === a && (a = 1024);\n        var e = c.wasmMaxTableSize;\n        b.table = \"object\" === (typeof WebAssembly === \"undefined\" ? \"undefined\" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(WebAssembly)) && \"function\" === typeof WebAssembly.Table ? void 0 !== e ? new WebAssembly.Table({\n          initial: a,\n          maximum: e,\n          element: \"anyfunc\"\n        }) : new WebAssembly.Table({\n          initial: a,\n          element: \"anyfunc\"\n        }) : Array(a);\n        c.wasmTable = b.table;\n      }\n\n      b.memoryBase || (b.memoryBase = c.STATIC_BASE);\n      b.tableBase || (b.tableBase = 0);\n      b = d(b);\n      assert(b, \"no binaryen method succeeded.\");\n      return b;\n    };\n  })();\n\n  sa = 1024;\n  C = sa + 9312;\n  Ca.push({\n    B: function B() {\n      La();\n    }\n  }, {\n    B: function B() {\n      Ma();\n    }\n  }, {\n    B: function B() {\n      Na();\n    }\n  }, {\n    B: function B() {\n      Oa();\n    }\n  });\n  c.STATIC_BASE = sa;\n  c.STATIC_BUMP = 9312;\n  C += 16;\n  var H = 0;\n\n  function I() {\n    H += 4;\n    return A[H - 4 >> 2];\n  }\n\n  var Pa = {};\n\n  function J(a, b) {\n    H = b;\n\n    try {\n      var d = I(),\n          e = I(),\n          f = I();\n      a = 0;\n      J.J || (J.J = [null, [], []], J.P = function (a, b) {\n        var d = J.J[a];\n        assert(d);\n\n        if (0 === b || 10 === b) {\n          a = 1 === a ? ha : x;\n\n          a: {\n            for (var e = b = 0; d[e];) {\n              ++e;\n            }\n\n            if (16 < e - b && d.subarray && la) b = la.decode(d.subarray(b, e));else for (e = \"\";;) {\n              var f = d[b++];\n\n              if (!f) {\n                b = e;\n                break a;\n              }\n\n              if (f & 128) {\n                var k = d[b++] & 63;\n                if (192 == (f & 224)) e += String.fromCharCode((f & 31) << 6 | k);else {\n                  var l = d[b++] & 63;\n                  if (224 == (f & 240)) f = (f & 15) << 12 | k << 6 | l;else {\n                    var h = d[b++] & 63;\n                    if (240 == (f & 248)) f = (f & 7) << 18 | k << 12 | l << 6 | h;else {\n                      var bb = d[b++] & 63;\n                      if (248 == (f & 252)) f = (f & 3) << 24 | k << 18 | l << 12 | h << 6 | bb;else {\n                        var m = d[b++] & 63;\n                        f = (f & 1) << 30 | k << 24 | l << 18 | h << 12 | bb << 6 | m;\n                      }\n                    }\n                  }\n                  65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));\n                }\n              } else e += String.fromCharCode(f);\n            }\n          }\n\n          a(b);\n          d.length = 0;\n        } else d.push(b);\n      });\n\n      for (b = 0; b < f; b++) {\n        for (var l = A[e + 8 * b >> 2], h = A[e + (8 * b + 4) >> 2], k = 0; k < h; k++) {\n          J.P(d, z[l + k]);\n        }\n\n        a += h;\n      }\n\n      return a;\n    } catch (m) {\n      return \"undefined\" !== typeof FS && m instanceof FS.I || y(m), -m.L;\n    }\n  }\n\n  function Qa(a) {\n    switch (a) {\n      case 1:\n        return 0;\n\n      case 2:\n        return 1;\n\n      case 4:\n        return 2;\n\n      case 8:\n        return 3;\n\n      default:\n        throw new TypeError(\"Unknown type size: \" + a);\n    }\n  }\n\n  var Ra = void 0;\n\n  function K(a) {\n    for (var b = \"\"; z[a];) {\n      b += Ra[z[a++]];\n    }\n\n    return b;\n  }\n\n  var L = {},\n      M = {},\n      Sa = {};\n\n  function Ta(a) {\n    if (void 0 === a) return \"_unknown\";\n    a = a.replace(/[^a-zA-Z0-9_]/g, \"$\");\n    var b = a.charCodeAt(0);\n    return 48 <= b && 57 >= b ? \"_\" + a : a;\n  }\n\n  function Ua(a, b) {\n    a = Ta(a);\n    return new Function(\"body\", \"return function \" + a + '() {\\n    \"use strict\";    return body.apply(this, arguments);\\n};\\n')(b);\n  }\n\n  function Va(a) {\n    var b = Error,\n        d = Ua(a, function (b) {\n      this.name = a;\n      this.message = b;\n      b = Error(b).stack;\n      void 0 !== b && (this.stack = this.toString() + \"\\n\" + b.replace(/^Error(:[^\\n]*)?\\n/, \"\"));\n    });\n    d.prototype = Object.create(b.prototype);\n    d.prototype.constructor = d;\n\n    d.prototype.toString = function () {\n      return void 0 === this.message ? this.name : this.name + \": \" + this.message;\n    };\n\n    return d;\n  }\n\n  var O = void 0;\n\n  function P(a) {\n    throw new O(a);\n  }\n\n  var Wa = void 0;\n\n  function Xa(a) {\n    throw new Wa(a);\n  }\n\n  function Ya(a, b, d) {\n    function e(b) {\n      b = d(b);\n      b.length !== a.length && Xa(\"Mismatched type converter count\");\n\n      for (var e = 0; e < a.length; ++e) {\n        Q(a[e], b[e]);\n      }\n    }\n\n    a.forEach(function (a) {\n      Sa[a] = b;\n    });\n    var f = Array(b.length),\n        l = [],\n        h = 0;\n    b.forEach(function (a, b) {\n      M.hasOwnProperty(a) ? f[b] = M[a] : (l.push(a), L.hasOwnProperty(a) || (L[a] = []), L[a].push(function () {\n        f[b] = M[a];\n        ++h;\n        h === l.length && e(f);\n      }));\n    });\n    0 === l.length && e(f);\n  }\n\n  function Q(a, b, d) {\n    d = d || {};\n    if (!(\"argPackAdvance\" in b)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n    var e = b.name;\n    a || P('type \"' + e + '\" must have a positive integer typeid pointer');\n\n    if (M.hasOwnProperty(a)) {\n      if (d.X) return;\n      P(\"Cannot register type '\" + e + \"' twice\");\n    }\n\n    M[a] = b;\n    delete Sa[a];\n    L.hasOwnProperty(a) && (b = L[a], delete L[a], b.forEach(function (a) {\n      a();\n    }));\n  }\n\n  function Za(a) {\n    P(a.a.f.b.name + \" instance already deleted\");\n  }\n\n  var $a = void 0,\n      ab = [];\n\n  function cb() {\n    for (; ab.length;) {\n      var a = ab.pop();\n      a.a.s = !1;\n      a[\"delete\"]();\n    }\n  }\n\n  function R() {}\n\n  var db = {};\n\n  function eb(a, b, d) {\n    if (void 0 === a[b].j) {\n      var e = a[b];\n\n      a[b] = function () {\n        a[b].j.hasOwnProperty(arguments.length) || P(\"Function '\" + d + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + a[b].j + \")!\");\n        return a[b].j[arguments.length].apply(this, arguments);\n      };\n\n      a[b].j = [];\n      a[b].j[e.A] = e;\n    }\n  }\n\n  function fb(a, b) {\n    c.hasOwnProperty(a) ? (P(\"Cannot register public name '\" + a + \"' twice\"), eb(c, a, a), c.hasOwnProperty(void 0) && P(\"Cannot register multiple overloads of a function with the same number of arguments (undefined)!\"), c[a].j[void 0] = b) : c[a] = b;\n  }\n\n  function gb(a, b, d, e, f, l, h, k) {\n    this.name = a;\n    this.constructor = b;\n    this.u = d;\n    this.o = e;\n    this.i = f;\n    this.T = l;\n    this.w = h;\n    this.S = k;\n    this.Z = [];\n  }\n\n  function hb(a, b, d) {\n    for (; b !== d;) {\n      b.w || P(\"Expected null or instance of \" + d.name + \", got an instance of \" + b.name), a = b.w(a), b = b.i;\n    }\n\n    return a;\n  }\n\n  function ib(a, b) {\n    if (null === b) return this.G && P(\"null is not a valid \" + this.name), 0;\n    b.a || P('Cannot pass \"' + S(b) + '\" as a ' + this.name);\n    b.a.c || P(\"Cannot pass deleted object as a pointer of type \" + this.name);\n    return hb(b.a.c, b.a.f.b, this.b);\n  }\n\n  function jb(a, b) {\n    if (null === b) {\n      this.G && P(\"null is not a valid \" + this.name);\n\n      if (this.D) {\n        var d = this.$();\n        null !== a && a.push(this.o, d);\n        return d;\n      }\n\n      return 0;\n    }\n\n    b.a || P('Cannot pass \"' + S(b) + '\" as a ' + this.name);\n    b.a.c || P(\"Cannot pass deleted object as a pointer of type \" + this.name);\n    !this.C && b.a.f.C && P(\"Cannot convert argument of type \" + (b.a.h ? b.a.h.name : b.a.f.name) + \" to parameter type \" + this.name);\n    d = hb(b.a.c, b.a.f.b, this.b);\n    if (this.D) switch (void 0 === b.a.g && P(\"Passing raw pointer to smart pointer is illegal\"), this.ba) {\n      case 0:\n        b.a.h === this ? d = b.a.g : P(\"Cannot convert argument of type \" + (b.a.h ? b.a.h.name : b.a.f.name) + \" to parameter type \" + this.name);\n        break;\n\n      case 1:\n        d = b.a.g;\n        break;\n\n      case 2:\n        if (b.a.h === this) d = b.a.g;else {\n          var e = b.clone();\n          d = this.aa(d, T(function () {\n            e[\"delete\"]();\n          }));\n          null !== a && a.push(this.o, d);\n        }\n        break;\n\n      default:\n        P(\"Unsupporting sharing policy\");\n    }\n    return d;\n  }\n\n  function kb(a, b) {\n    if (null === b) return this.G && P(\"null is not a valid \" + this.name), 0;\n    b.a || P('Cannot pass \"' + S(b) + '\" as a ' + this.name);\n    b.a.c || P(\"Cannot pass deleted object as a pointer of type \" + this.name);\n    b.a.f.C && P(\"Cannot convert argument of type \" + b.a.f.name + \" to parameter type \" + this.name);\n    return hb(b.a.c, b.a.f.b, this.b);\n  }\n\n  function lb(a) {\n    return this.fromWireType(B[a >> 2]);\n  }\n\n  function ob(a, b, d) {\n    if (b === d) return a;\n    if (void 0 === d.i) return null;\n    a = ob(a, b, d.i);\n    return null === a ? null : d.S(a);\n  }\n\n  var pb = {};\n\n  function qb(a, b) {\n    for (void 0 === b && P(\"ptr should not be undefined\"); a.i;) {\n      b = a.w(b), a = a.i;\n    }\n\n    return pb[b];\n  }\n\n  function rb(a, b) {\n    b.f && b.c || Xa(\"makeClassHandle requires ptr and ptrType\");\n    !!b.h !== !!b.g && Xa(\"Both smartPtrType and smartPtr must be specified\");\n    b.count = {\n      value: 1\n    };\n    return Object.create(a, {\n      a: {\n        value: b\n      }\n    });\n  }\n\n  function U(a, b, d, e, f, l, h, k, m, p, g) {\n    this.name = a;\n    this.b = b;\n    this.G = d;\n    this.C = e;\n    this.D = f;\n    this.Y = l;\n    this.ba = h;\n    this.M = k;\n    this.$ = m;\n    this.aa = p;\n    this.o = g;\n    f || void 0 !== b.i ? this.toWireType = jb : (this.toWireType = e ? ib : kb, this.l = null);\n  }\n\n  function sb(a, b) {\n    c.hasOwnProperty(a) || Xa(\"Replacing nonexistant public symbol\");\n    c[a] = b;\n    c[a].A = void 0;\n  }\n\n  function V(a, b) {\n    a = K(a);\n    if (void 0 !== c[\"FUNCTION_TABLE_\" + a]) var d = c[\"FUNCTION_TABLE_\" + a][b];else if (\"undefined\" !== typeof FUNCTION_TABLE) d = FUNCTION_TABLE[b];else {\n      d = c.asm[\"dynCall_\" + a];\n      void 0 === d && (d = c.asm[\"dynCall_\" + a.replace(/f/g, \"d\")], void 0 === d && P(\"No dynCall invoker for signature: \" + a));\n\n      for (var e = [], f = 1; f < a.length; ++f) {\n        e.push(\"a\" + f);\n      }\n\n      f = \"return function \" + (\"dynCall_\" + a + \"_\" + b) + \"(\" + e.join(\", \") + \") {\\n\";\n      f += \"    return dynCall(rawFunction\" + (e.length ? \", \" : \"\") + e.join(\", \") + \");\\n\";\n      d = new Function(\"dynCall\", \"rawFunction\", f + \"};\\n\")(d, b);\n    }\n    \"function\" !== typeof d && P(\"unknown function pointer with signature \" + a + \": \" + b);\n    return d;\n  }\n\n  var tb = void 0;\n\n  function ub(a) {\n    a = wb(a);\n    var b = K(a);\n    X(a);\n    return b;\n  }\n\n  function xb(a, b) {\n    function d(a) {\n      f[a] || M[a] || (Sa[a] ? Sa[a].forEach(d) : (e.push(a), f[a] = !0));\n    }\n\n    var e = [],\n        f = {};\n    b.forEach(d);\n    throw new tb(a + \": \" + e.map(ub).join([\", \"]));\n  }\n\n  function yb(a, b) {\n    for (var d = [], e = 0; e < a; e++) {\n      d.push(A[(b >> 2) + e]);\n    }\n\n    return d;\n  }\n\n  function zb(a) {\n    for (; a.length;) {\n      var b = a.pop();\n      a.pop()(b);\n    }\n  }\n\n  function Ab(a) {\n    var b = Function;\n    if (!(b instanceof Function)) throw new TypeError(\"new_ called with constructor type \" + _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(b) + \" which is not a function\");\n    var d = Ua(b.name || \"unknownFunctionName\", function () {});\n    d.prototype = b.prototype;\n    d = new d();\n    a = b.apply(d, a);\n    return a instanceof Object ? a : d;\n  }\n\n  var Bb = [],\n      Y = [{}, {\n    value: void 0\n  }, {\n    value: null\n  }, {\n    value: !0\n  }, {\n    value: !1\n  }];\n\n  function Cb(a) {\n    4 < a && 0 === --Y[a].H && (Y[a] = void 0, Bb.push(a));\n  }\n\n  function T(a) {\n    switch (a) {\n      case void 0:\n        return 1;\n\n      case null:\n        return 2;\n\n      case !0:\n        return 3;\n\n      case !1:\n        return 4;\n\n      default:\n        var b = Bb.length ? Bb.pop() : Y.length;\n        Y[b] = {\n          H: 1,\n          value: a\n        };\n        return b;\n    }\n  }\n\n  function S(a) {\n    if (null === a) return \"null\";\n\n    var b = _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(a);\n\n    return \"object\" === b || \"array\" === b || \"function\" === b ? a.toString() : \"\" + a;\n  }\n\n  function Db(a, b) {\n    switch (b) {\n      case 2:\n        return function (a) {\n          return this.fromWireType(pa[a >> 2]);\n        };\n\n      case 3:\n        return function (a) {\n          return this.fromWireType(qa[a >> 3]);\n        };\n\n      default:\n        throw new TypeError(\"Unknown float type: \" + a);\n    }\n  }\n\n  function Eb(a, b, d) {\n    switch (b) {\n      case 0:\n        return d ? function (a) {\n          return ma[a];\n        } : function (a) {\n          return z[a];\n        };\n\n      case 1:\n        return d ? function (a) {\n          return na[a >> 1];\n        } : function (a) {\n          return oa[a >> 1];\n        };\n\n      case 2:\n        return d ? function (a) {\n          return A[a >> 2];\n        } : function (a) {\n          return B[a >> 2];\n        };\n\n      default:\n        throw new TypeError(\"Unknown integer type: \" + a);\n    }\n  }\n\n  function Z(a) {\n    a || P(\"Cannot use deleted val. handle = \" + a);\n    return Y[a].value;\n  }\n\n  function Fb(a, b) {\n    var d = M[a];\n    void 0 === d && P(b + \" has unknown type \" + ub(a));\n    return d;\n  }\n\n  for (var Gb = {}, Hb = Array(256), Ib = 0; 256 > Ib; ++Ib) {\n    Hb[Ib] = String.fromCharCode(Ib);\n  }\n\n  Ra = Hb;\n  O = c.BindingError = Va(\"BindingError\");\n  Wa = c.InternalError = Va(\"InternalError\");\n\n  R.prototype.isAliasOf = function (a) {\n    if (!(this instanceof R && a instanceof R)) return !1;\n    var b = this.a.f.b,\n        d = this.a.c,\n        e = a.a.f.b;\n\n    for (a = a.a.c; b.i;) {\n      d = b.w(d), b = b.i;\n    }\n\n    for (; e.i;) {\n      a = e.w(a), e = e.i;\n    }\n\n    return b === e && d === a;\n  };\n\n  R.prototype.clone = function () {\n    this.a.c || Za(this);\n    if (this.a.v) return this.a.count.value += 1, this;\n    var a = this.a;\n    a = Object.create(Object.getPrototypeOf(this), {\n      a: {\n        value: {\n          count: a.count,\n          s: a.s,\n          v: a.v,\n          c: a.c,\n          f: a.f,\n          g: a.g,\n          h: a.h\n        }\n      }\n    });\n    a.a.count.value += 1;\n    a.a.s = !1;\n    return a;\n  };\n\n  R.prototype[\"delete\"] = function () {\n    this.a.c || Za(this);\n    this.a.s && !this.a.v && P(\"Object already scheduled for deletion\");\n    --this.a.count.value;\n\n    if (0 === this.a.count.value) {\n      var a = this.a;\n      a.g ? a.h.o(a.g) : a.f.b.o(a.c);\n    }\n\n    this.a.v || (this.a.g = void 0, this.a.c = void 0);\n  };\n\n  R.prototype.isDeleted = function () {\n    return !this.a.c;\n  };\n\n  R.prototype.deleteLater = function () {\n    this.a.c || Za(this);\n    this.a.s && !this.a.v && P(\"Object already scheduled for deletion\");\n    ab.push(this);\n    1 === ab.length && $a && $a(cb);\n    this.a.s = !0;\n    return this;\n  };\n\n  U.prototype.U = function (a) {\n    this.M && (a = this.M(a));\n    return a;\n  };\n\n  U.prototype.K = function (a) {\n    this.o && this.o(a);\n  };\n\n  U.prototype.argPackAdvance = 8;\n  U.prototype.readValueFromPointer = lb;\n\n  U.prototype.deleteObject = function (a) {\n    if (null !== a) a[\"delete\"]();\n  };\n\n  U.prototype.fromWireType = function (a) {\n    function b() {\n      return this.D ? rb(this.b.u, {\n        f: this.Y,\n        c: d,\n        h: this,\n        g: a\n      }) : rb(this.b.u, {\n        f: this,\n        c: a\n      });\n    }\n\n    var d = this.U(a);\n    if (!d) return this.K(a), null;\n    var e = qb(this.b, d);\n\n    if (void 0 !== e) {\n      if (0 === e.a.count.value) return e.a.c = d, e.a.g = a, e.clone();\n      e = e.clone();\n      this.K(a);\n      return e;\n    }\n\n    e = this.b.T(d);\n    e = db[e];\n    if (!e) return b.call(this);\n    e = this.C ? e.R : e.pointerType;\n    var f = ob(d, this.b, e.b);\n    return null === f ? b.call(this) : this.D ? rb(e.b.u, {\n      f: e,\n      c: f,\n      h: this,\n      g: a\n    }) : rb(e.b.u, {\n      f: e,\n      c: f\n    });\n  };\n\n  c.getInheritedInstanceCount = function () {\n    return Object.keys(pb).length;\n  };\n\n  c.getLiveInheritedInstances = function () {\n    var a = [],\n        b;\n\n    for (b in pb) {\n      pb.hasOwnProperty(b) && a.push(pb[b]);\n    }\n\n    return a;\n  };\n\n  c.flushPendingDeletes = cb;\n\n  c.setDelayFunction = function (a) {\n    $a = a;\n    ab.length && $a && $a(cb);\n  };\n\n  tb = c.UnboundTypeError = Va(\"UnboundTypeError\");\n\n  c.count_emval_handles = function () {\n    for (var a = 0, b = 5; b < Y.length; ++b) {\n      void 0 !== Y[b] && ++a;\n    }\n\n    return a;\n  };\n\n  c.get_first_emval = function () {\n    for (var a = 5; a < Y.length; ++a) {\n      if (void 0 !== Y[a]) return Y[a];\n    }\n\n    return null;\n  };\n\n  var Jb = C;\n  C = C + 4 + 15 & -16;\n  xa = Jb;\n  ta = ua = ia(C);\n  va = ta + za;\n  wa = ia(va);\n  A[xa >> 2] = wa;\n  c.wasmTableSize = 83;\n  c.wasmMaxTableSize = 83;\n  c.N = {};\n  c.O = {\n    abort: y,\n    enlargeMemory: function enlargeMemory() {\n      ya();\n    },\n    getTotalMemory: function getTotalMemory() {\n      return E;\n    },\n    abortOnCannotGrowMemory: ya,\n    ___setErrNo: function ___setErrNo(a) {\n      c.___errno_location && (A[c.___errno_location() >> 2] = a);\n      return a;\n    },\n    ___syscall140: function ___syscall140(a, b) {\n      H = b;\n\n      try {\n        var d = Pa.V();\n        I();\n        var e = I(),\n            f = I(),\n            l = I();\n        FS.ea(d, e, l);\n        A[f >> 2] = d.position;\n        d.W && 0 === e && 0 === l && (d.W = null);\n        return 0;\n      } catch (h) {\n        return \"undefined\" !== typeof FS && h instanceof FS.I || y(h), -h.L;\n      }\n    },\n    ___syscall146: J,\n    ___syscall54: function ___syscall54(a, b) {\n      H = b;\n      return 0;\n    },\n    ___syscall6: function ___syscall6(a, b) {\n      H = b;\n\n      try {\n        var d = Pa.V();\n        FS.close(d);\n        return 0;\n      } catch (e) {\n        return \"undefined\" !== typeof FS && e instanceof FS.I || y(e), -e.L;\n      }\n    },\n    __embind_register_bool: function __embind_register_bool(a, b, d, e, f) {\n      var l = Qa(d);\n      b = K(b);\n      Q(a, {\n        name: b,\n        fromWireType: function fromWireType(a) {\n          return !!a;\n        },\n        toWireType: function toWireType(a, b) {\n          return b ? e : f;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: function readValueFromPointer(a) {\n          if (1 === d) var e = ma;else if (2 === d) e = na;else if (4 === d) e = A;else throw new TypeError(\"Unknown boolean type size: \" + b);\n          return this.fromWireType(e[a >> l]);\n        },\n        l: null\n      });\n    },\n    __embind_register_class: function __embind_register_class(a, b, d, e, f, l, h, k, m, p, g, q, D) {\n      g = K(g);\n      l = V(f, l);\n      k && (k = V(h, k));\n      p && (p = V(m, p));\n      D = V(q, D);\n      var t = Ta(g);\n      fb(t, function () {\n        xb(\"Cannot construct \" + g + \" due to unbound types\", [e]);\n      });\n      Ya([a, b, d], e ? [e] : [], function (b) {\n        b = b[0];\n\n        if (e) {\n          var d = b.b;\n          var f = d.u;\n        } else f = R.prototype;\n\n        b = Ua(t, function () {\n          if (Object.getPrototypeOf(this) !== h) throw new O(\"Use 'new' to construct \" + g);\n          if (void 0 === m.m) throw new O(g + \" has no accessible constructor\");\n          var a = m.m[arguments.length];\n          if (void 0 === a) throw new O(\"Tried to invoke ctor of \" + g + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(m.m).toString() + \") parameters instead!\");\n          return a.apply(this, arguments);\n        });\n        var h = Object.create(f, {\n          constructor: {\n            value: b\n          }\n        });\n        b.prototype = h;\n        var m = new gb(g, b, h, D, d, l, k, p);\n        d = new U(g, m, !0, !1, !1);\n        f = new U(g + \"*\", m, !1, !1, !1);\n        var q = new U(g + \" const*\", m, !1, !0, !1);\n        db[a] = {\n          pointerType: f,\n          R: q\n        };\n        sb(t, b);\n        return [d, f, q];\n      });\n    },\n    __embind_register_class_constructor: function __embind_register_class_constructor(a, b, d, e, f, l) {\n      var h = yb(b, d);\n      f = V(e, f);\n      Ya([], [a], function (a) {\n        a = a[0];\n        var d = \"constructor \" + a.name;\n        void 0 === a.b.m && (a.b.m = []);\n        if (void 0 !== a.b.m[b - 1]) throw new O(\"Cannot register multiple constructors with identical number of parameters (\" + (b - 1) + \") for class '\" + a.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n\n        a.b.m[b - 1] = function () {\n          xb(\"Cannot construct \" + a.name + \" due to unbound types\", h);\n        };\n\n        Ya([], h, function (e) {\n          a.b.m[b - 1] = function () {\n            arguments.length !== b - 1 && P(d + \" called with \" + arguments.length + \" arguments, expected \" + (b - 1));\n            var a = [],\n                h = Array(b);\n            h[0] = l;\n\n            for (var k = 1; k < b; ++k) {\n              h[k] = e[k].toWireType(a, arguments[k - 1]);\n            }\n\n            h = f.apply(null, h);\n            zb(a);\n            return e[0].fromWireType(h);\n          };\n\n          return [];\n        });\n        return [];\n      });\n    },\n    __embind_register_class_function: function __embind_register_class_function(a, b, d, e, f, l, h, k) {\n      var m = yb(d, e);\n      b = K(b);\n      l = V(f, l);\n      Ya([], [a], function (a) {\n        function e() {\n          xb(\"Cannot call \" + f + \" due to unbound types\", m);\n        }\n\n        a = a[0];\n        var f = a.name + \".\" + b;\n        k && a.b.Z.push(b);\n        var p = a.b.u,\n            t = p[b];\n        void 0 === t || void 0 === t.j && t.className !== a.name && t.A === d - 2 ? (e.A = d - 2, e.className = a.name, p[b] = e) : (eb(p, b, f), p[b].j[d - 2] = e);\n        Ya([], m, function (e) {\n          var k = f,\n              g = a,\n              m = l,\n              q = e.length;\n          2 > q && P(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n          var t = null !== e[1] && null !== g,\n              D = !1;\n\n          for (g = 1; g < e.length; ++g) {\n            if (null !== e[g] && void 0 === e[g].l) {\n              D = !0;\n              break;\n            }\n          }\n\n          var mb = \"void\" !== e[0].name,\n              N = \"\",\n              W = \"\";\n\n          for (g = 0; g < q - 2; ++g) {\n            N += (0 !== g ? \", \" : \"\") + \"arg\" + g, W += (0 !== g ? \", \" : \"\") + \"arg\" + g + \"Wired\";\n          }\n\n          k = \"return function \" + Ta(k) + \"(\" + N + \") {\\nif (arguments.length !== \" + (q - 2) + \") {\\nthrowBindingError('function \" + k + \" called with ' + arguments.length + ' arguments, expected \" + (q - 2) + \" args!');\\n}\\n\";\n          D && (k += \"var destructors = [];\\n\");\n          var nb = D ? \"destructors\" : \"null\";\n          N = \"throwBindingError invoker fn runDestructors retType classParam\".split(\" \");\n          m = [P, m, h, zb, e[0], e[1]];\n          t && (k += \"var thisWired = classParam.toWireType(\" + nb + \", this);\\n\");\n\n          for (g = 0; g < q - 2; ++g) {\n            k += \"var arg\" + g + \"Wired = argType\" + g + \".toWireType(\" + nb + \", arg\" + g + \"); // \" + e[g + 2].name + \"\\n\", N.push(\"argType\" + g), m.push(e[g + 2]);\n          }\n\n          t && (W = \"thisWired\" + (0 < W.length ? \", \" : \"\") + W);\n          k += (mb ? \"var rv = \" : \"\") + \"invoker(fn\" + (0 < W.length ? \", \" : \"\") + W + \");\\n\";\n          if (D) k += \"runDestructors(destructors);\\n\";else for (g = t ? 1 : 2; g < e.length; ++g) {\n            q = 1 === g ? \"thisWired\" : \"arg\" + (g - 2) + \"Wired\", null !== e[g].l && (k += q + \"_dtor(\" + q + \"); // \" + e[g].name + \"\\n\", N.push(q + \"_dtor\"), m.push(e[g].l));\n          }\n          mb && (k += \"var ret = retType.fromWireType(rv);\\nreturn ret;\\n\");\n          N.push(k + \"}\\n\");\n          e = Ab(N).apply(null, m);\n          void 0 === p[b].j ? (e.A = d - 2, p[b] = e) : p[b].j[d - 2] = e;\n          return [];\n        });\n        return [];\n      });\n    },\n    __embind_register_emval: function __embind_register_emval(a, b) {\n      b = K(b);\n      Q(a, {\n        name: b,\n        fromWireType: function fromWireType(a) {\n          var b = Y[a].value;\n          Cb(a);\n          return b;\n        },\n        toWireType: function toWireType(a, b) {\n          return T(b);\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: lb,\n        l: null\n      });\n    },\n    __embind_register_float: function __embind_register_float(a, b, d) {\n      d = Qa(d);\n      b = K(b);\n      Q(a, {\n        name: b,\n        fromWireType: function fromWireType(a) {\n          return a;\n        },\n        toWireType: function toWireType(a, b) {\n          if (\"number\" !== typeof b && \"boolean\" !== typeof b) throw new TypeError('Cannot convert \"' + S(b) + '\" to ' + this.name);\n          return b;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: Db(b, d),\n        l: null\n      });\n    },\n    __embind_register_integer: function __embind_register_integer(a, b, d, e, f) {\n      function l(a) {\n        return a;\n      }\n\n      b = K(b);\n      -1 === f && (f = 4294967295);\n      var h = Qa(d);\n\n      if (0 === e) {\n        var k = 32 - 8 * d;\n\n        l = function l(a) {\n          return a << k >>> k;\n        };\n      }\n\n      var m = -1 != b.indexOf(\"unsigned\");\n      Q(a, {\n        name: b,\n        fromWireType: l,\n        toWireType: function toWireType(a, d) {\n          if (\"number\" !== typeof d && \"boolean\" !== typeof d) throw new TypeError('Cannot convert \"' + S(d) + '\" to ' + this.name);\n          if (d < e || d > f) throw new TypeError('Passing a number \"' + S(d) + '\" from JS side to C/C++ side to an argument of type \"' + b + '\", which is outside the valid range [' + e + \", \" + f + \"]!\");\n          return m ? d >>> 0 : d | 0;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: Eb(b, h, 0 !== e),\n        l: null\n      });\n    },\n    __embind_register_memory_view: function __embind_register_memory_view(a, b, d) {\n      function e(a) {\n        a >>= 2;\n        var b = B;\n        return new f(b.buffer, b[a + 1], b[a]);\n      }\n\n      var f = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];\n      d = K(d);\n      Q(a, {\n        name: d,\n        fromWireType: e,\n        argPackAdvance: 8,\n        readValueFromPointer: e\n      }, {\n        X: !0\n      });\n    },\n    __embind_register_std_string: function __embind_register_std_string(a, b) {\n      b = K(b);\n      Q(a, {\n        name: b,\n        fromWireType: function fromWireType(a) {\n          for (var b = B[a >> 2], d = Array(b), l = 0; l < b; ++l) {\n            d[l] = String.fromCharCode(z[a + 4 + l]);\n          }\n\n          X(a);\n          return d.join(\"\");\n        },\n        toWireType: function toWireType(a, b) {\n          function d(a, b) {\n            return a[b];\n          }\n\n          function e(a, b) {\n            return a.charCodeAt(b);\n          }\n\n          b instanceof ArrayBuffer && (b = new Uint8Array(b));\n          var h;\n          b instanceof Uint8Array ? h = d : b instanceof Uint8ClampedArray ? h = d : b instanceof Int8Array ? h = d : \"string\" === typeof b ? h = e : P(\"Cannot pass non-string to std::string\");\n          var k = b.length,\n              m = Kb(4 + k);\n          B[m >> 2] = k;\n\n          for (var p = 0; p < k; ++p) {\n            var g = h(b, p);\n            255 < g && (X(m), P(\"String has UTF-16 code units that do not fit in 8 bits\"));\n            z[m + 4 + p] = g;\n          }\n\n          null !== a && a.push(X, m);\n          return m;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: lb,\n        l: function l(a) {\n          X(a);\n        }\n      });\n    },\n    __embind_register_std_wstring: function __embind_register_std_wstring(a, b, d) {\n      d = K(d);\n\n      if (2 === b) {\n        var e = function e() {\n          return oa;\n        };\n\n        var f = 1;\n      } else 4 === b && (e = function e() {\n        return B;\n      }, f = 2);\n\n      Q(a, {\n        name: d,\n        fromWireType: function fromWireType(a) {\n          for (var b = e(), d = B[a >> 2], l = Array(d), p = a + 4 >> f, g = 0; g < d; ++g) {\n            l[g] = String.fromCharCode(b[p + g]);\n          }\n\n          X(a);\n          return l.join(\"\");\n        },\n        toWireType: function toWireType(a, d) {\n          var k = e(),\n              h = d.length,\n              l = Kb(4 + h * b);\n          B[l >> 2] = h;\n\n          for (var g = l + 4 >> f, q = 0; q < h; ++q) {\n            k[g + q] = d.charCodeAt(q);\n          }\n\n          null !== a && a.push(X, l);\n          return l;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: lb,\n        l: function l(a) {\n          X(a);\n        }\n      });\n    },\n    __embind_register_void: function __embind_register_void(a, b) {\n      b = K(b);\n      Q(a, {\n        da: !0,\n        name: b,\n        argPackAdvance: 0,\n        fromWireType: function fromWireType() {},\n        toWireType: function toWireType() {}\n      });\n    },\n    __emval_as: function __emval_as(a, b, d) {\n      a = Z(a);\n      b = Fb(b, \"emval::as\");\n      var e = [],\n          f = T(e);\n      A[d >> 2] = f;\n      return b.toWireType(e, a);\n    },\n    __emval_decref: Cb,\n    __emval_get_property: function __emval_get_property(a, b) {\n      a = Z(a);\n      b = Z(b);\n      return T(a[b]);\n    },\n    __emval_incref: function __emval_incref(a) {\n      4 < a && (Y[a].H += 1);\n    },\n    __emval_new_array: function __emval_new_array() {\n      return T([]);\n    },\n    __emval_new_cstring: function __emval_new_cstring(a) {\n      var b = Gb[a];\n      return T(void 0 === b ? K(a) : b);\n    },\n    __emval_new_object: function __emval_new_object() {\n      return T({});\n    },\n    __emval_run_destructors: function __emval_run_destructors(a) {\n      zb(Y[a].value);\n      Cb(a);\n    },\n    __emval_set_property: function __emval_set_property(a, b, d) {\n      a = Z(a);\n      b = Z(b);\n      d = Z(d);\n      a[b] = d;\n    },\n    __emval_take_value: function __emval_take_value(a, b) {\n      a = Fb(a, \"_emval_take_value\");\n      a = a.readValueFromPointer(b);\n      return T(a);\n    },\n    _abort: function _abort() {\n      c.abort();\n    },\n    _emscripten_memcpy_big: function _emscripten_memcpy_big(a, b, d) {\n      z.set(z.subarray(b, b + d), a);\n      return a;\n    },\n    _llvm_cos_f32: Ha,\n    _llvm_log10_f32: function _llvm_log10_f32(a) {\n      return Math.log(a) / Math.LN10;\n    },\n    _llvm_sin_f32: Ia,\n    DYNAMICTOP_PTR: xa,\n    STACKTOP: ua\n  };\n  var Lb = c.asm(c.N, c.O, buffer);\n  c.asm = Lb;\n\n  var Oa = c.__GLOBAL__sub_I_bind_cpp = function () {\n    return c.asm.__GLOBAL__sub_I_bind_cpp.apply(null, arguments);\n  },\n      La = c.__GLOBAL__sub_I_fft_cc = function () {\n    return c.asm.__GLOBAL__sub_I_fft_cc.apply(null, arguments);\n  },\n      Na = c.__GLOBAL__sub_I_pitch_cc = function () {\n    return c.asm.__GLOBAL__sub_I_pitch_cc.apply(null, arguments);\n  },\n      Ma = c.__GLOBAL__sub_I_tempo_cc = function () {\n    return c.asm.__GLOBAL__sub_I_tempo_cc.apply(null, arguments);\n  },\n      wb = c.___getTypeName = function () {\n    return c.asm.___getTypeName.apply(null, arguments);\n  },\n      X = c._free = function () {\n    return c.asm._free.apply(null, arguments);\n  },\n      Kb = c._malloc = function () {\n    return c.asm._malloc.apply(null, arguments);\n  };\n\n  c.dynCall_ffii = function () {\n    return c.asm.dynCall_ffii.apply(null, arguments);\n  };\n\n  c.dynCall_fi = function () {\n    return c.asm.dynCall_fi.apply(null, arguments);\n  };\n\n  c.dynCall_fii = function () {\n    return c.asm.dynCall_fii.apply(null, arguments);\n  };\n\n  c.dynCall_fiii = function () {\n    return c.asm.dynCall_fiii.apply(null, arguments);\n  };\n\n  c.dynCall_ii = function () {\n    return c.asm.dynCall_ii.apply(null, arguments);\n  };\n\n  c.dynCall_iii = function () {\n    return c.asm.dynCall_iii.apply(null, arguments);\n  };\n\n  c.dynCall_iiii = function () {\n    return c.asm.dynCall_iiii.apply(null, arguments);\n  };\n\n  c.dynCall_iiiii = function () {\n    return c.asm.dynCall_iiiii.apply(null, arguments);\n  };\n\n  c.dynCall_iiiiii = function () {\n    return c.asm.dynCall_iiiiii.apply(null, arguments);\n  };\n\n  c.dynCall_v = function () {\n    return c.asm.dynCall_v.apply(null, arguments);\n  };\n\n  c.dynCall_vi = function () {\n    return c.asm.dynCall_vi.apply(null, arguments);\n  };\n\n  c.dynCall_viii = function () {\n    return c.asm.dynCall_viii.apply(null, arguments);\n  };\n\n  c.asm = Lb;\n\n  c.then = function (a) {\n    if (c.calledRun) a(c);else {\n      var b = c.onRuntimeInitialized;\n\n      c.onRuntimeInitialized = function () {\n        b && b();\n        a(c);\n      };\n    }\n    return c;\n  };\n\n  G = function Mb() {\n    c.calledRun || Nb();\n    c.calledRun || (G = Mb);\n  };\n\n  function Nb() {\n    function a() {\n      if (!c.calledRun && (c.calledRun = !0, !ka)) {\n        Fa || (Fa = !0, Aa(Ca));\n        Aa(Da);\n        if (c.onRuntimeInitialized) c.onRuntimeInitialized();\n        if (c.postRun) for (\"function\" == typeof c.postRun && (c.postRun = [c.postRun]); c.postRun.length;) {\n          var a = c.postRun.shift();\n          Ea.unshift(a);\n        }\n        Aa(Ea);\n      }\n    }\n\n    if (!(0 < F)) {\n      if (c.preRun) for (\"function\" == typeof c.preRun && (c.preRun = [c.preRun]); c.preRun.length;) {\n        Ga();\n      }\n      Aa(Ba);\n      0 < F || c.calledRun || (c.setStatus ? (c.setStatus(\"Running...\"), setTimeout(function () {\n        setTimeout(function () {\n          c.setStatus(\"\");\n        }, 1);\n        a();\n      }, 1)) : a());\n    }\n  }\n\n  c.run = Nb;\n\n  function y(a) {\n    if (c.onAbort) c.onAbort(a);\n    void 0 !== a ? (ha(a), x(a), a = JSON.stringify(a)) : a = \"\";\n    ka = !0;\n    throw \"abort(\" + a + \"). Build with -s ASSERTIONS=1 for more info.\";\n  }\n\n  c.abort = y;\n  if (c.preInit) for (\"function\" == typeof c.preInit && (c.preInit = [c.preInit]); 0 < c.preInit.length;) {\n    c.preInit.pop()();\n  }\n  c.noExitRuntime = !0;\n  Nb();\n  return _Aubio;\n};\n\nAubio = Aubio.bind({\n  _currentScript: typeof document !== 'undefined' ? document.currentScript : undefined\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Aubio);\n\n//# sourceURL=webpack://frequencyRecognizer/./external/aubio.js?");

/***/ }),

/***/ "./lib/frequency-recognizer.js":
/*!*************************************!*\
  !*** ./lib/frequency-recognizer.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\nvar Aubio = __webpack_require__(/*! ../external/aubio.js */ \"./external/aubio.js\");\n\nvar utils = __webpack_require__(/*! ./utils.js */ \"./lib/utils.js\");\n\nvar FrequencyRecognizerNode = function FrequencyRecognizerNode(audioContext) {\n  var _this = this;\n\n  _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, FrequencyRecognizerNode);\n\n  _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"audioProcessCallback\", function (e) {\n    var frequency = _this.pitchDetector[\"do\"](e.inputBuffer.getChannelData(0));\n\n    console.log(frequency);\n\n    if (frequency) {\n      _this.frequency = frequency.toFixed(1);\n    }\n  });\n\n  _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"startRecognize\", function () {\n    Aubio().then( /*#__PURE__*/function () {\n      var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(aubio) {\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this.pitchDetector = new aubio.Pitch(\"default\", 2048, 1, _this.audioContext.sampleRate);\n                _context.next = 3;\n                return navigator.mediaDevices.getUserMedia({\n                  audio: true\n                }).then(function (stream) {\n                  _this.stream = stream;\n                  _this.scriptProcessor = _this.audioContext.createScriptProcessor(2048, 1, 1);\n                  _this.mediaStreamSource = _this.audioContext.createMediaStreamSource(stream);\n\n                  var analyser = _this.audioContext.createAnalyser();\n\n                  analyser.fftSize = 2048;\n\n                  _this.mediaStreamSource.connect(analyser);\n\n                  analyser.connect(_this.scriptProcessor);\n\n                  _this.scriptProcessor.connect(_this.audioContext.destination);\n\n                  _this.scriptProcessor.onaudioprocess = _this.audioProcessCallback;\n                });\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  });\n\n  _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"init\", function () {\n    utils.initGetUserMedia();\n\n    _this.startRecognize();\n  });\n\n  _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"destroy\", function () {\n    _this.frequency = null;\n    _this.pitchDetector = null;\n\n    if (_this.scriptProcessor) {\n      _this.scriptProcessor.onaudioprocess = null;\n      _this.scriptProcessor = null;\n    }\n\n    if (_this.stream) {\n      _this.stream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n    }\n\n    if (_this.mediaStreamSource && _this.mediaStreamSource.mediaStream && _this.mediaStreamSource.mediaStream.stop) {\n      _this.mediaStreamSource.mediaStream.stop();\n    }\n  });\n\n  this.audioContext = audioContext || utils.getAudioContext();\n  this.stream = null;\n  this.frequency = null;\n  this.pitchDetector = null;\n  this.mediaStreamSource = null;\n  this.scriptProcessor = null;\n};\n\nvar FrequencyRecognizerNodeWrapper = function () {\n  var instance;\n\n  function createInstance(audioContext) {\n    var object = new FrequencyRecognizerNode(audioContext);\n    return object;\n  }\n\n  return {\n    getInstance: function getInstance(audioContext) {\n      if (!instance) {\n        instance = createInstance(audioContext);\n      }\n\n      return instance;\n    }\n  };\n}();\n\nmodule.exports = FrequencyRecognizerNodeWrapper;\n\n//# sourceURL=webpack://frequencyRecognizer/./lib/frequency-recognizer.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var FrequencyRecognizerNode = __webpack_require__(/*! ./frequency-recognizer */ \"./lib/frequency-recognizer.js\");\n\nvar _require = __webpack_require__(/*! ./utils */ \"./lib/utils.js\"),\n    getAudioContext = _require.getAudioContext,\n    initGetUserMedia = _require.initGetUserMedia;\n\nmodule.exports = {\n  FrequencyRecognizerNode: FrequencyRecognizerNode,\n  getAudioContext: getAudioContext,\n  initGetUserMedia: initGetUserMedia\n};\n\n//# sourceURL=webpack://frequencyRecognizer/./lib/index.js?");

/***/ }),

/***/ "./lib/utils.js":
/*!**********************!*\
  !*** ./lib/utils.js ***!
  \**********************/
/***/ ((module) => {

eval("var getAudioContext = function getAudioContext() {\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n  if (!window.AudioContext) {\n    throw new Error(\"Web Audio API is not supported in this browser\");\n  }\n\n  return new window.AudioContext();\n};\n\nvar initGetUserMedia = function initGetUserMedia() {\n  if (navigator.mediaDevices === undefined) {\n    navigator.mediaDevices = {};\n  }\n\n  if (navigator.mediaDevices.getUserMedia === undefined) {\n    navigator.mediaDevices.getUserMedia = function (constraints) {\n      var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n\n      if (!getUserMedia) {\n        throw new Error(\"getUserMedia is not implemented in this browser\");\n      }\n\n      return new Promise(function (resolve, reject) {\n        getUserMedia.call(navigator, constraints, resolve, reject);\n      });\n    };\n  }\n};\n\nmodule.exports = {\n  getAudioContext: getAudioContext,\n  initGetUserMedia: initGetUserMedia\n};\n\n//# sourceURL=webpack://frequencyRecognizer/./lib/utils.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack://frequencyRecognizer/./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./lib/index.js");
/******/ })()
;
});